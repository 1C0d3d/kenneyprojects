<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Chess vs AI</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: radial-gradient(circle, #4b2e05 0%, #2a1c04 100%);
    background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
    background-size: cover;
    font-family: "Georgia", serif;
    color: #fff8e7;
    text-align: center;
    overflow: hidden;
    height: 100%;
  }
  #game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    width: 90vmin;
    height: 90vmin;
    border: 5px solid #3c2605;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    user-select: none;
  }
  .square {
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: calc(5vmin);
    transition: all 0.3s ease;
  }
  .light { background: #e8c28c; }
  .dark { background: #7b4e1e; }
  .highlight { outline: 3px solid gold; }
  #controls {
    margin-top: 15px;
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
  }
  label, button {
    background: #5a3812;
    color: #fff8e7;
    border: 2px solid #3c2605;
    padding: 8px 14px;
    border-radius: 6px;
    font-family: inherit;
    cursor: pointer;
    transition: 0.3s;
  }
  button:hover { background: #7a4d18; }
  #status { margin-top: 10px; font-size: 18px; }
  #scoreboard { margin-top: 8px; font-size: 16px; }
  #backBtn {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: #3c2605;
    padding: 12px 20px;
    border-radius: 10px;
    font-size: 16px;
    color: #fff8e7;
    border: none;
    cursor: pointer;
  }
  #backArrow {
    display: none;
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: #3c2605;
    border-radius: 50%;
    width: 45px;
    height: 45px;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    cursor: pointer;
    color: white;
  }
  @media (max-width: 600px) {
    #backBtn { display: none; }
    #backArrow { display: flex; }
  }
</style>
</head>
<body>
<div id="game-container">
  <h1>♔ Elegant Chess vs Hard AI ♚</h1>
  <div id="board"></div>
  <div id="controls">
    <label><input type="checkbox" id="showHints" checked> Show Hints</label>
    <button id="resetScore">Reset Scoreboard</button>
  </div>
  <div id="status">Your Move</div>
  <div id="scoreboard"></div>
</div>
<button id="backBtn" onclick="window.location.href='games.html'">← Back to Games</button>
<div id="backArrow" onclick="window.location.href='games.html'">⬅️</div>

<script>
// Core setup
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const scoreEl = document.getElementById('scoreboard');
const showHints = document.getElementById('showHints');
const resetScoreBtn = document.getElementById('resetScore');

let board = [];
let selected = null;
let wins = parseInt(localStorage.getItem('chessWins')) || 0;
let losses = parseInt(localStorage.getItem('chessLosses')) || 0;
let aiThinking = false;

const pieces = {
  white: { king:'♔', queen:'♕', rook:'♖', bishop:'♗', knight:'♘', pawn:'♙' },
  black: { king:'♚', queen:'♛', rook:'♜', bishop:'♝', knight:'♞', pawn:'♟' }
};

function updateScoreboard() {
  scoreEl.textContent = `Wins: ${wins} | Losses: ${losses}`;
}
updateScoreboard();

function initBoard() {
  board = [
    ['♜','♞','♝','♛','♚','♝','♞','♜'],
    ['♟','♟','♟','♟','♟','♟','♟','♟'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['♙','♙','♙','♙','♙','♙','♙','♙'],
    ['♖','♘','♗','♕','♔','♗','♘','♖']
  ];
}
initBoard();

function isWhite(p){ return '♙♖♘♗♕♔'.includes(p); }
function isBlack(p){ return '♟♜♞♝♛♚'.includes(p); }

function renderBoard() {
  boardEl.innerHTML='';
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const sq=document.createElement('div');
      sq.classList.add('square',(r+c)%2===0?'light':'dark');
      sq.dataset.row=r; sq.dataset.col=c;
      sq.textContent=board[r][c];
      if(showHints.checked && selected){
        const moves=getLegalMoves(selected.row,selected.col);
        if(moves.some(m=>m.row===r && m.col===c)) sq.classList.add('highlight');
      }
      sq.onclick=()=>handleSquareClick(r,c);
      boardEl.appendChild(sq);
    }
  }
}

function handleSquareClick(r,c){
  if(aiThinking) return;
  if(selected){
    const moves=getLegalMoves(selected.row,selected.col);
    const valid=moves.some(m=>m.row===r&&m.col===c);
    if(valid){ movePiece(selected.row,selected.col,r,c); }
    selected=null;
    renderBoard();
  } else if(board[r][c] && isWhite(board[r][c])){
    selected={row:r,col:c};
    renderBoard();
  }
}

function getLegalMoves(row,col){
  const piece=board[row][col];
  if(!piece) return [];
  const lower=piece.toLowerCase();
  const moves=[];
  const add=(r,c)=>{ if(r>=0&&r<8&&c>=0&&c<8) moves.push({row:r,col:c}); };
  const dirs={
    rook:[[1,0],[-1,0],[0,1],[0,-1]],
    bishop:[[1,1],[1,-1],[-1,1],[-1,-1]],
    queen:[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],
    knight:[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]],
    king:[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]
  };
  if(lower==='♙'){ // white pawn
    if(!board[row-1][col]) add(row-1,col);
    if(row===6 && !board[row-1][col] && !board[row-2][col]) add(row-2,col);
    if(isBlack(board[row-1]?.[col-1])) add(row-1,col-1);
    if(isBlack(board[row-1]?.[col+1])) add(row-1,col+1);
  }
  else if(lower==='♟'){ // black pawn
    if(!board[row+1][col]) add(row+1,col);
    if(row===1 && !board[row+1][col] && !board[row+2][col]) add(row+2,col);
    if(isWhite(board[row+1]?.[col-1])) add(row+1,col-1);
    if(isWhite(board[row+1]?.[col+1])) add(row+1,col+1);
  }
  else if(['♖','♜'].includes(piece)){
    for(const [dr,dc] of dirs.rook){
      let r=row+dr,c=col+dc;
      while(r>=0&&r<8&&c>=0&&c<8){
        if(board[r][c]){
          if(isWhite(piece)!=isWhite(board[r][c])) add(r,c);
          break;
        }
        add(r,c); r+=dr; c+=dc;
      }
    }
  }
  else if(['♗','♝'].includes(piece)){
    for(const [dr,dc] of dirs.bishop){
      let r=row+dr,c=col+dc;
      while(r>=0&&r<8&&c>=0&&c<8){
        if(board[r][c]){
          if(isWhite(piece)!=isWhite(board[r][c])) add(r,c);
          break;
        }
        add(r,c); r+=dr; c+=dc;
      }
    }
  }
  else if(['♕','♛'].includes(piece)){
    for(const [dr,dc] of dirs.queen){
      let r=row+dr,c=col+dc;
      while(r>=0&&r<8&&c>=0&&c<8){
        if(board[r][c]){
          if(isWhite(piece)!=isWhite(board[r][c])) add(r,c);
          break;
        }
        add(r,c); r+=dr; c+=dc;
      }
    }
  }
  else if(['♘','♞'].includes(piece)){
    for(const [dr,dc] of dirs.knight) add(row+dr,col+dc);
  }
  else if(['♔','♚'].includes(piece)){
    for(const [dr,dc] of dirs.king) add(row+dr,col+dc);
  }
  return moves.filter(m=>{
    const target=board[m.row][m.col];
    return !target || isWhite(piece)!==isWhite(target);
  });
}

function movePiece(sr,sc,tr,tc){
  const piece=board[sr][sc];
  const target=board[tr][tc];
  board[tr][tc]=piece;
  board[sr][sc]='';
  // promotion
  if(piece==='♙' && tr===0) board[tr][tc]='♕';
  if(piece==='♟' && tr===7) board[tr][tc]='♛';
  renderBoard();
  if(isBlack(target) && target==='♚'){
    wins++;
    localStorage.setItem('chessWins',wins);
    updateScoreboard();
    alert('You won!');
    initBoard(); renderBoard(); return;
  }
  aiTurn();
}

function aiTurn(){
  aiThinking=true;
  statusEl.textContent='Computer Thinking...';
  setTimeout(()=>{
    const move=findBestMove(3);
    if(move){
      const {from,to}=move;
      const piece=board[from.row][from.col];
      const target=board[to.row][to.col];
      board[to.row][to.col]=piece;
      board[from.row][from.col]='';
      if(piece==='♟' && to.row===7) board[to.row][to.col]='♛';
      renderBoard();
      if(isWhite(target)&&target==='♔'){
        losses++;
        localStorage.setItem('chessLosses',losses);
        updateScoreboard();
        alert('The AI has won!');
        initBoard(); renderBoard();
      }
    }
    aiThinking=false;
    statusEl.textContent='Your Move';
  },1000);
}

function cloneBoard(b){ return b.map(r=>r.slice()); }

function evaluate(b){
  const val={
    '♙':1,'♘':3,'♗':3,'♖':5,'♕':9,'♔':1000,
    '♟':-1,'♞':-3,'♝':-3,'♜':-5,'♛':-9,'♚':-1000
  };
  let sum=0;
  for(let r=0;r<8;r++)for(let c=0;c<8;c++) if(b[r][c]) sum+=val[b[r][c]]||0;
  return sum;
}

function findBestMove(depth){
  let best=-Infinity; let bestMove=null;
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){
    const piece=board[r][c];
    if(!isBlack(piece)) continue;
    const moves=getLegalMoves(r,c);
    for(const move of moves){
      const copy=cloneBoard(board);
      const temp=copy[move.row][move.col];
      copy[move.row][move.col]=piece; copy[r][c]='';
      const val=minimax(copy,depth-1,false,-Infinity,Infinity);
      if(val>best || (val===best && Math.random()>0.5)){
        best=val; bestMove={from:{row:r,col:c},to:move};
      }
    }
  }
  return bestMove;
}

function minimax(b,depth,maximizing,alpha,beta){
  if(depth===0) return evaluate(b);
  if(maximizing){
    let max=-Infinity;
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){
      const piece=b[r][c];
      if(!isBlack(piece)) continue;
      const moves=getLegalMoves(r,c);
      for(const move of moves){
        const temp=b[move.row][move.col];
        b[move.row][move.col]=piece; b[r][c]='';
        const val=minimax(b,depth-1,false,alpha,beta);
        b[r][c]=piece; b[move.row][move.col]=temp;
        max=Math.max(max,val); alpha=Math.max(alpha,val);
        if(beta<=alpha) return max;
      }
    }
    return max;
  } else {
    let min=Infinity;
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){
      const piece=b[r][c];
      if(!isWhite(piece)) continue;
      const moves=getLegalMoves(r,c);
      for(const move of moves){
        const temp=b[move.row][move.col];
        b[move.row][move.col]=piece; b[r][c]='';
        const val=minimax(b,depth-1,true,alpha,beta);
        b[r][c]=piece; b[move.row][move.col]=temp;
        min=Math.min(min,val); beta=Math.min(beta,val);
        if(beta<=alpha) return min;
      }
    }
    return min;
  }
}

resetScoreBtn.onclick=()=>{wins=0;losses=0;localStorage.setItem('chessWins',0);localStorage.setItem('chessLosses',0);updateScoreboard();};
renderBoard();
</script>
</body>
</html>
