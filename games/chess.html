<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Elegant Chess vs AI</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: radial-gradient(circle, #4b2e05 0%, #2a1c04 100%);
    background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
    background-size: cover;
    font-family: "Georgia", serif;
    color: #fff8e7;
    text-align: center;
    overflow: hidden;
  }

  #game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
  }

  #board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    width: 90vmin;
    height: 90vmin;
    border: 5px solid #3c2605;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    user-select: none;
  }

  .square {
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: calc(5vmin);
    transition: all 0.25s ease;
  }

  .light {
    background: #e8c28c;
  }
  .dark {
    background: #7b4e1e;
  }
  .highlight {
    outline: 3px solid gold;
  }

  #controls {
    margin-top: 15px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
  }

  select, button, label {
    background: #5a3812;
    color: #fff8e7;
    border: 2px solid #3c2605;
    padding: 8px 14px;
    border-radius: 6px;
    font-family: inherit;
    cursor: pointer;
    transition: 0.3s;
  }

  button:hover, select:hover {
    background: #7a4d18;
  }

  #status {
    margin-top: 10px;
    font-size: 18px;
  }

  #scoreboard {
    margin-top: 8px;
    font-size: 16px;
  }

  #backBtn {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: #3c2605;
    padding: 12px 20px;
    border-radius: 10px;
    font-size: 16px;
    color: #fff8e7;
    border: none;
    cursor: pointer;
  }

  #backArrow {
    display: none;
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: #3c2605;
    border-radius: 50%;
    width: 45px;
    height: 45px;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    cursor: pointer;
  }

  @media (max-width: 600px) {
    #backBtn { display: none; }
    #backArrow { display: flex; }
  }
</style>
</head>
<body>
<div id="game-container">
  <h1>♔ Elegant Chess vs AI ♚</h1>
  <div id="board"></div>

  <div id="controls">
    <label>
      Difficulty:
      <select id="difficulty">
        <option value="1">Easy</option>
        <option value="2">Medium</option>
        <option value="3" selected>Hard</option>
      </select>
    </label>

    <label>
      <input type="checkbox" id="showHints" checked /> Show Hints
    </label>

    <button id="resetScore">Reset Scoreboard</button>
  </div>

  <div id="status">Your Move</div>
  <div id="scoreboard"></div>
</div>

<button id="backBtn" onclick="window.location.href='games.html'">← Back to Games</button>
<div id="backArrow" onclick="window.location.href='games.html'">⬅️</div>

<script>
// --- Basic Chess Setup ---
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const scoreEl = document.getElementById('scoreboard');
const showHints = document.getElementById('showHints');
const resetScoreBtn = document.getElementById('resetScore');
const diffSelect = document.getElementById('difficulty');

let board = [];
let selected = null;
let currentPlayer = 'white';
let aiThinking = false;

let wins = parseInt(localStorage.getItem('chessWins')) || 0;
let losses = parseInt(localStorage.getItem('chessLosses')) || 0;

function updateScoreboard() {
  scoreEl.textContent = `Wins: ${wins} | Losses: ${losses}`;
}
updateScoreboard();

// --- Pieces ---
const pieces = {
  white: { king:'♔', queen:'♕', rook:'♖', bishop:'♗', knight:'♘', pawn:'♙' },
  black: { king:'♚', queen:'♛', rook:'♜', bishop:'♝', knight:'♞', pawn:'♟' }
};

// --- Initialize Board ---
function initBoard() {
  board = [
    ['♜','♞','♝','♛','♚','♝','♞','♜'],
    ['♟','♟','♟','♟','♟','♟','♟','♟'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['♙','♙','♙','♙','♙','♙','♙','♙'],
    ['♖','♘','♗','♕','♔','♗','♘','♖']
  ];
}
initBoard();

// --- Render Board ---
function renderBoard() {
  boardEl.innerHTML = '';
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const square = document.createElement('div');
      square.classList.add('square', (row + col) % 2 === 0 ? 'light' : 'dark');
      square.dataset.row = row;
      square.dataset.col = col;
      square.textContent = board[row][col];
      if (showHints.checked && selected) {
        let legal = getLegalMoves(selected.row, selected.col);
        if (legal.some(m => m.row === row && m.col === col)) {
          square.classList.add('highlight');
        }
      }
      square.onclick = () => handleSquareClick(row, col);
      boardEl.appendChild(square);
    }
  }
}
renderBoard();

// --- Game Logic Simplified ---
function handleSquareClick(row, col) {
  if (aiThinking) return;
  const piece = board[row][col];
  if (selected) {
    const moves = getLegalMoves(selected.row, selected.col);
    const isValid = moves.some(m => m.row === row && m.col === col);
    if (isValid) movePiece(selected.row, selected.col, row, col);
    selected = null;
    renderBoard();
  } else if (piece && isWhite(piece)) {
    selected = { row, col };
    renderBoard();
  }
}

function isWhite(p) {
  return '♙♖♘♗♕♔'.includes(p);
}
function isBlack(p) {
  return '♟♜♞♝♛♚'.includes(p);
}

// --- Move Logic (basic legal moves + AI math) ---
function getLegalMoves(row, col) {
  // Simple move generator for demo (pawns, rooks, knights, bishops, queens, kings)
  const piece = board[row][col];
  let moves = [];
  if (!piece) return moves;

  const directions = {
    rook: [[1,0],[-1,0],[0,1],[0,-1]],
    bishop: [[1,1],[1,-1],[-1,1],[-1,-1]],
    queen: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],
    knight: [[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]],
    king: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]
  };

  const addMove = (r,c) => {
    if (r>=0 && c>=0 && r<8 && c<8) moves.push({row:r,col:c});
  };

  const lower = piece.toLowerCase();
  if (lower === '♙') {
    if (!board[row-1][col]) addMove(row-1,col);
    if (isBlack(board[row-1][col-1])) addMove(row-1,col-1);
    if (isBlack(board[row-1][col+1])) addMove(row-1,col+1);
  }
  else if (lower === '♟') {
    if (!board[row+1][col]) addMove(row+1,col);
    if (isWhite(board[row+1][col-1])) addMove(row+1,col-1);
    if (isWhite(board[row+1][col+1])) addMove(row+1,col+1);
  }
  else if (['♖','♜'].includes(piece)) {
    for (let [dr,dc] of directions.rook) {
      let r=row+dr,c=col+dc;
      while (r>=0&&c>=0&&r<8&&c<8) {
        if (board[r][c]) { if (isWhite(piece)!=isWhite(board[r][c])) addMove(r,c); break; }
        addMove(r,c); r+=dr;c+=dc;
      }
    }
  }
  else if (['♗','♝'].includes(piece)) {
    for (let [dr,dc] of directions.bishop) {
      let r=row+dr,c=col+dc;
      while (r>=0&&c>=0&&r<8&&c<8) {
        if (board[r][c]) { if (isWhite(piece)!=isWhite(board[r][c])) addMove(r,c); break; }
        addMove(r,c); r+=dr;c+=dc;
      }
    }
  }
  else if (['♕','♛'].includes(piece)) {
    for (let [dr,dc] of directions.queen) {
      let r=row+dr,c=col+dc;
      while (r>=0&&c>=0&&r<8&&c<8) {
        if (board[r][c]) { if (isWhite(piece)!=isWhite(board[r][c])) addMove(r,c); break; }
        addMove(r,c); r+=dr;c+=dc;
      }
    }
  }
  else if (['♘','♞'].includes(piece)) {
    for (let [dr,dc] of directions.knight) addMove(row+dr,col+dc);
  }
  else if (['♔','♚'].includes(piece)) {
    for (let [dr,dc] of directions.king) addMove(row+dr,col+dc);
  }

  // Filter out friendly fire
  moves = moves.filter(m => {
    const target = board[m.row][m.col];
    if (!target) return true;
    return isWhite(piece) !== isWhite(target);
  });

  return moves;
}

function movePiece(sr, sc, tr, tc) {
  const piece = board[sr][sc];
  const target = board[tr][tc];
  board[tr][tc] = piece;
  board[sr][sc] = '';
  renderBoard();

  if (isBlack(target) && target === '♚') {
    wins++;
    localStorage.setItem('chessWins', wins);
    updateScoreboard();
    alert('You won!');
    initBoard();
    renderBoard();
    return;
  }

  currentPlayer = 'black';
  aiTurn();
}

function aiTurn() {
  aiThinking = true;
  statusEl.textContent = 'Computer Thinking...';
  setTimeout(() => {
    const move = findBestMove();
    if (move) movePieceAI(move);
    aiThinking = false;
    currentPlayer = 'white';
    statusEl.textContent = 'Your Move';
    renderBoard();
  }, 1000);
}

function movePieceAI(move) {
  const { from, to } = move;
  const piece = board[from.row][from.col];
  const target = board[to.row][to.col];
  board[to.row][to.col] = piece;
  board[from.row][from.col] = '';
  if (isWhite(target) && target === '♔') {
    losses++;
    localStorage.setItem('chessLosses', losses);
    updateScoreboard();
    alert('The AI has won!');
    initBoard();
    renderBoard();
  }
}

// --- Minimax (simplified) ---
function evaluateBoard() {
  let val = 0;
  const pieceValues = {
    '♙': 1, '♘': 3, '♗': 3, '♖': 5, '♕': 9, '♔': 1000,
    '♟': -1, '♞': -3, '♝': -3, '♜': -5, '♛': -9, '♚': -1000
  };
  for (let r=0;r<8;r++) for (let c=0;c<8;c++) {
    if (board[r][c]) val += pieceValues[board[r][c]] || 0;
  }
  return val;
}

function findBestMove() {
  const depth = parseInt(diffSelect.value) + 1;
  let bestVal = -Infinity;
  let bestMove = null;
  for (let r=0;r<8;r++) {
    for (let c=0;c<8;c++) {
      const piece = board[r][c];
      if (!isBlack(piece)) continue;
      const moves = getLegalMoves(r,c);
      for (let move of moves) {
        const backup = board[move.row][move.col];
        board[move.row][move.col] = piece;
        board[r][c] = '';
        const value = minimax(depth-1, false, -Infinity, Infinity);
        board[r][c] = piece;
        board[move.row][move.col] = backup;
        if (value > bestVal) {
          bestVal = value;
          bestMove = { from: {row:r,col:c}, to: move };
        }
      }
    }
  }
  return bestMove;
}

function minimax(depth, isMax, alpha, beta) {
  if (depth === 0) return evaluateBoard();
  if (isMax) {
    let maxEval = -Infinity;
    for (let r=0;r<8;r++) {
      for (let c=0;c<8;c++) {
        const piece = board[r][c];
        if (!isBlack(piece)) continue;
        const moves = getLegalMoves(r,c);
        for (let move of moves) {
          const backup = board[move.row][move.col];
          board[move.row][move.col] = piece;
          board[r][c] = '';
          const evalVal = minimax(depth-1,false,alpha,beta);
          board[r][c] = piece;
          board[move.row][move.col] = backup;
          maxEval = Math.max(maxEval, evalVal);
          alpha = Math.max(alpha, evalVal);
          if (beta <= alpha) break;
        }
      }
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (let r=0;r<8;r++) {
      for (let c=0;c<8;c++) {
        const piece = board[r][c];
        if (!isWhite(piece)) continue;
        const moves = getLegalMoves(r,c);
        for (let move of moves) {
          const backup = board[move.row][move.col];
          board[move.row][move.col] = piece;
          board[r][c] = '';
          const evalVal = minimax(depth-1,true,alpha,beta);
          board[r][c] = piece;
          board[move.row][move.col] = backup;
          minEval = Math.min(minEval, evalVal);
          beta = Math.min(beta, evalVal);
          if (beta <= alpha) break;
        }
      }
    }
    return minEval;
  }
}

// --- Reset Scoreboard ---
resetScoreBtn.onclick = () => {
  wins = 0; losses = 0;
  localStorage.setItem('chessWins', 0);
  localStorage.setItem('chessLosses', 0);
  updateScoreboard();
};

</script>
</body>
</html>
