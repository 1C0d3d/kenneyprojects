<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Arcade Tetris</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    color: #fff;
    font-family: 'Courier New', monospace;
    height: 100%;
    text-align: center;
  }

  #game {
    display: block;
    margin: auto;
    background: #111;
    outline: 4px solid #555;
  }

  #hud {
    margin-top: 10px;
    font-size: 20px;
  }

  #backBtn {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: #333;
    color: #fff;
    padding: 10px 18px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
  }

  #backArrow {
    display: none;
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: #333;
    border-radius: 50%;
    width: 45px;
    height: 45px;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    color: white;
    cursor: pointer;
  }

  @media (max-width: 600px) {
    #backBtn { display: none; }
    #backArrow { display: flex; }
  }

  #gameOver {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #f00;
    font-size: 40px;
    font-weight: bold;
    display: none;
  }
</style>
</head>
<body>
<h1>üïπÔ∏è Arcade Tetris üß±</h1>
<div id="hud">
  <span id="score">Score: 0</span> |
  <span id="level">Level: 1</span> |
  <span id="best">Best: 0</span>
</div>
<canvas id="game" width="300" height="600" tabindex="0"></canvas>
<div id="gameOver">GAME OVER<br><small>Press Enter to Restart</small></div>
<button id="backBtn" onclick="window.location.href='https://www.kenneyprojects.com/games'">‚Üê Back to Games</button>
<div id="backArrow">‚¨ÖÔ∏è</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const gameOverText = document.getElementById('gameOver');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const bestEl = document.getElementById('best');

  const COLS = 10, ROWS = 20;
  const BLOCK = 30;
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;

  const COLORS = [null,'#0ff','#00f','#f60','#ff0','#0c0','#90c','#f00'];

  // ‚úÖ Store each shape in its base orientation only
  const SHAPES = {
    I: [[1,1,1,1]],
    J: [[2,0,0],[2,2,2]],
    L: [[0,0,3],[3,3,3]],
    O: [[4,4],[4,4]],
    S: [[0,5,5],[5,5,0]],
    T: [[0,6,0],[6,6,6]],
    Z: [[7,7,0],[0,7,7]]
  };
  const TYPES = Object.keys(SHAPES);

  let arena = Array.from({length:ROWS},()=>Array(COLS).fill(0));
  let player = {};
  let score = 0, best = +localStorage.getItem('tetrisBest')||0, level = 1;
  let dropCounter = 0, dropInterval = 1000;
  let lastTime = 0, running = true;

  function drawMatrix(matrix, offset){
    matrix.forEach((row,y)=>{
      row.forEach((v,x)=>{
        if(v){
          ctx.fillStyle = COLORS[v];
          ctx.fillRect((x+offset.x)*BLOCK, (y+offset.y)*BLOCK, BLOCK-1, BLOCK-1);
        }
      });
    });
  }

  function draw(){
    ctx.fillStyle='#111';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle='#888';
    ctx.lineWidth=4;
    ctx.strokeRect(0,0,canvas.width,canvas.height);
    drawMatrix(arena,{x:0,y:0});
    drawMatrix(player.matrix,player.pos);
  }

  function collide(arena, player){
    const [m,p]=[player.matrix,player.pos];
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(m[y][x]&&(arena[y+p.y]&&arena[y+p.y][x+p.x])!==0) return true;
      }
    }
    return false;
  }

  function merge(arena, player){
    player.matrix.forEach((row,y)=>{
      row.forEach((v,x)=>{
        if(v) arena[y+player.pos.y][x+player.pos.x]=v;
      });
    });
  }

  function sweep(){
    let lines=0;
    outer: for(let y=ROWS-1;y>=0;y--){
      for(let x=0;x<COLS;x++){
        if(arena[y][x]===0) continue outer;
      }
      arena.splice(y,1);
      arena.unshift(Array(COLS).fill(0));
      lines++;
    }
    if(lines){
      score+=lines*100;
      if(score>best){
        best=score;
        localStorage.setItem('tetrisBest',best);
      }
      level = Math.floor(score/500)+1;
      dropInterval = Math.max(200,1000-(level-1)*100);
      updateHUD();
    }
  }

  function updateHUD(){
    scoreEl.textContent = `Score: ${score}`;
    levelEl.textContent = `Level: ${level}`;
    bestEl.textContent = `Best: ${best}`;
  }

  function playerReset(){
    const type=TYPES[(Math.random()*TYPES.length)|0];
    player.matrix=SHAPES[type].map(row=>row.slice()); // clone base shape
    player.pos={x:(COLS/2|0)-(player.matrix[0].length/2|0),y:0};
    if(collide(arena,player)){
      running=false;
      gameOver();
    }
  }

  // ‚úÖ Fixed rotation (transpose + reverse rows)
  function rotate(matrix, dir = 1){
    const rotated = matrix.map((_,i)=>matrix.map(row=>row[i]));
    if(dir > 0) rotated.forEach(row=>row.reverse());
    else rotated.reverse();
    return rotated;
  }

  function playerRotate(dir = 1){
    const pos=player.pos.x;
    let offset=1;
    const oldMatrix = player.matrix;
    player.matrix = rotate(player.matrix, dir);
    while(collide(arena,player)){
      player.pos.x += offset;
      offset = -(offset + (offset>0?1:-1));
      if(offset > player.matrix[0].length){
        player.matrix = oldMatrix;
        player.pos.x = pos;
        return;
      }
    }
  }

  function drop(){
    player.pos.y++;
    if(collide(arena,player)){
      player.pos.y--;
      merge(arena,player);
      sweep();
      playerReset();
    }
    dropCounter=0;
  }

  function move(offset){
    player.pos.x+=offset;
    if(collide(arena,player)) player.pos.x-=offset;
  }

  function update(time=0){
    const delta=time-lastTime;
    lastTime=time;
    if(!running) return;
    dropCounter+=delta;
    if(dropCounter>dropInterval) drop();
    draw();
    requestAnimationFrame(update);
  }

  function restart(){
    arena=Array.from({length:ROWS},()=>Array(COLS).fill(0));
    score=0;level=1;dropInterval=1000;
    running=true;
    gameOverText.style.display='none';
    playerReset();
    updateHUD();
    update();
  }

  function gameOver(){
    gameOverText.style.display='block';
  }

  document.addEventListener('keydown',e=>{
    if(!running && e.key==='Enter'){restart();return;}
    if(!running) return;
    if(e.key==='ArrowLeft') move(-1);
    else if(e.key==='ArrowRight') move(1);
    else if(e.key==='ArrowDown') drop();
    else if(e.key==='ArrowUp') playerRotate(1);
    else if(e.key===' ') {
      while(!collide(arena,{matrix:player.matrix,pos:{x:player.pos.x,y:player.pos.y+1}}))
        player.pos.y++;
      drop();
    }
  });

  playerReset();
  updateHUD();
  update();
})();
</script>
</body>
</html>
