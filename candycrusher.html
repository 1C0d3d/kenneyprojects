<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Candy Land Match3</title>
<style>
  @keyframes popFloat {
    0% { transform: translateY(0) scale(1); opacity: 1; }
    40% { transform: translateY(-8px) scale(1.5); opacity: 1; }
    100% { transform: translateY(-80px) scale(1.2); opacity: 0; }
  }
  @keyframes shatter {
    0% { transform: scale(1); opacity: 1; filter: blur(0); }
    50% { transform: scale(1.05) rotate(-6deg); opacity: 1; }
    100% { transform: scale(1.2) rotate(10deg); opacity: 0; filter: blur(6px); }
  }
  body, html {
    margin: 0; padding: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: url('https://images.unsplash.com/photo-1505250469679-203ad9ced0cb?w=1600&q=80&auto=format&fit=crop') no-repeat center/cover;
  }
  #root {
    height: 100%;
    display: flex; align-items: center; justify-content: center;
    padding: 20px;
  }
  .game-container {
    background: rgba(255,255,255,0.85);
    border-radius: 24px;
    padding: 16px;
    box-shadow: 0 6px 16px rgba(0,0,0,0.3);
    user-select: none;
    max-width: 95vmin;
    max-height: 95vmin;
    display: flex;
    flex-direction: column;
  }
  .hud {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-weight: 700;
  }
  .hearts {
    font-size: 1.25rem;
    color: crimson;
  }
  .score {
    font-size: 1.25rem;
    color: #444;
  }
  .timer-bar {
    height: 14px;
    background: rgba(0,0,0,0.1);
    border-radius: 7px;
    overflow: hidden;
    margin-bottom: 10px;
  }
  .timer-bar-inner {
    height: 100%;
    transition: width 0.1s linear;
    background: linear-gradient(90deg, #3adf7c, #33c36f);
  }
  .board {
    display: grid;
    gap: 6px;
    flex-grow: 1;
    touch-action: manipulation;
  }
  .cell {
    background: linear-gradient(180deg, #fff, #eee);
    border-radius: 10px;
    box-shadow: 0 6px 12px rgba(0,0,0,0.12);
    font-size: 1.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    cursor: pointer;
    user-select: none;
    transition: transform 0.15s ease;
  }
  .cell.selected {
    transform: scale(1.1);
    box-shadow: 0 8px 16px rgba(255, 77, 166, 0.8);
    z-index: 2;
  }
  .frozen-overlay {
    position: absolute;
    inset: 0;
    border-radius: 10px;
    background: linear-gradient(180deg, rgba(180,230,255,0.25), rgba(140,200,255,0.18));
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .frozen-ice {
    position: absolute;
    inset: 0;
    border-radius: 10px;
    background-image: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
    backdrop-filter: saturate(120%) blur(2px);
  }
  .frozen-svg {
    position: relative;
    z-index: 3;
  }
  .matched-pop > div {
    animation: popFloat 480ms forwards;
  }
  .matched-shatter > div {
    animation: shatter 420ms forwards;
    background: linear-gradient(180deg,#e6f7ff,#d4f0ff);
  }
  .game-over {
    color: red;
    font-size: 3rem;
    font-weight: 900;
    text-align: center;
    text-shadow: 1px 1px 6px crimson;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    margin-bottom: 15px;
  }
  .game-over-info {
    font-size: 1.25rem;
    margin-bottom: 25px;
    text-align: center;
  }
  .restart-button {
    cursor: pointer;
    background: crimson;
    color: white;
    border: none;
    padding: 14px 28px;
    font-size: 1.25rem;
    border-radius: 12px;
    font-weight: 700;
    user-select: none;
    transition: background 0.3s ease;
  }
  .restart-button:hover {
    background: #a30000;
  }
</style>
</head>
<body>
<div id="root"></div>

<!-- React & ReactDOM from CDN -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

<script>
(() => {
  const { useState, useEffect, useRef } = React;

  const CANDIES = ["üç¨", "üç≠", "üç´", "üç™", "üç©", "üçí", "üçá", "üçì"];
  const START_HEARTS = 5;
  const TIMER_SECONDS = 7.0;

  function computeGridSize(width, height) {
    const shortSide = Math.min(width, height);
    if (shortSide < 420) return 7;
    if (shortSide < 600) return 8;
    if (shortSide < 900) return 9;
    if (shortSide < 1200) return 10;
    if (shortSide < 1600) return 11;
    return 12;
  }

  function emptyTile() {
    return { kind: null, frozen: false };
  }

  function shade(hex, percent) {
    const num = parseInt(hex.slice(1), 16);
    const r = Math.max(0, Math.min(255, (num >> 16) + percent));
    const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + percent));
    const b = Math.max(0, Math.min(255, (num & 0x0000FF) + percent));
    return `rgb(${r},${g},${b})`;
  }

  function TimerBar({ timeLeft, total }) {
    const pct = Math.max(0, Math.min(1, timeLeft / total));
    const color = pct > 0.6 ? "#3adf7c" : pct > 0.3 ? "#ffd24d" : "#ff6b6b";
    return React.createElement("div", { className: "timer-bar" },
      React.createElement("div", {
        className: "timer-bar-inner",
        style: {
          width: `${pct * 100}%`,
          background: `linear-gradient(90deg, ${color}, ${shade(color, -12)})`
        }
      })
    );
  }

  function CandyLandMatch3() {
    const [cols, setCols] = useState(8);
    const [rows, setRows] = useState(8);
    const [grid, setGrid] = useState([]);
    const [score, setScore] = useState(0);
    const [highScore, setHighScore] = useState(0);
    const [selected, setSelected] = useState(null);
    const [hearts, setHearts] = useState(START_HEARTS);
    const [animating, setAnimating] = useState(false);
    const [matchedMap, setMatchedMap] = useState(new Map());
    const [timeLeft, setTimeLeft] = useState(TIMER_SECONDS);
    const [gameOver, setGameOver] = useState(false);

    const timerRef = useRef(null);
    const firstMoveRef = useRef(false);

    useEffect(() => {
      function onResize() {
        const size = computeGridSize(window.innerWidth, window.innerHeight);
        setCols(size);
        setRows(size);
      }
      onResize();
      window.addEventListener("resize", onResize);
      return () => window.removeEventListener("resize", onResize);
    }, []);

    useEffect(() => {
      const saved = parseInt(localStorage.getItem("cl_highscore") || "0", 10);
      setHighScore(isNaN(saved) ? 0 : saved);
      initBoard(rows, cols);
    }, [rows, cols]);

    useEffect(() => {
      if (score > highScore) {
        setHighScore(score);
        localStorage.setItem("cl_highscore", String(score));
      }
    }, [score, highScore]);

    useEffect(() => {
      if (hearts <= 0) {
        setGameOver(true);
        stopTimer();
      }
    }, [hearts]);

    function stopTimer() {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    }

    function startTimer() {
      stopTimer();
      timerRef.current = setInterval(() => {
        setTimeLeft((t) => {
          const next = t - 0.1;
          if (next <= 0) {
            handleTimerExpiry();
            return TIMER_SECONDS;
          }
          return next;
        });
      }, 100);
    }

    function handleTimerExpiry() {
      setHearts((h) => Math.max(0, h - 1));
      setSelected(null);
    }

    function initBoard(r, c) {
      const size = r * c;
      const b = Array(size)
        .fill(0)
        .map(() => ({ kind: randKind(), frozen: false }));
      for (let i = 0; i < size; i++) {
        let tries = 0;
        while (hasImmediateMatchAt(b, i, r, c) && tries < 12) {
          b[i].kind = randKind();
          tries++;
        }
      }
      const initialFrozen = Math.max(1, Math.floor(size * 0.03));
      for (let k = 0; k < initialFrozen; k++) {
        const idx = Math.floor(Math.random() * size);
        b[idx].frozen = true;
      }
      setGrid(b);
      setScore(0);
      setHearts(START_HEARTS);
      setSelected(null);
      setMatchedMap(new Map());
      setTimeLeft(TIMER_SECONDS);
      stopTimer();
      firstMoveRef.current = false;
      setGameOver(false);
    }

    function randKind() {
      return Math.floor(Math.random() * CANDIES.length);
    }

    function hasImmediateMatchAt(b, idx, r, c) {
      const val = b[idx].kind;
      if (val === null) return false;
      const row = Math.floor(idx / c);
      const col = idx % c;
      if (col >= 2 && b[row * c + col - 1].kind === val && b[row * c + col - 2].kind === val)
        return true;
      if (row >= 2 && b[(row - 1) * c + col].kind === val && b[(row - 2) * c + col].kind === val)
        return true;
      return false;
    }

    function indexToRC(i) {
      return [Math.floor(i / cols), i % cols];
    }
    function rcToIndex(r, c) {
      return r * cols + c;
    }

    function areNeighbors(a, b) {
      if (a == null || b == null) return false;
      const [ra, ca] = indexToRC(a);
      const [rb, cb] = indexToRC(b);
      return Math.abs(ra - rb) + Math.abs(ca - cb) === 1;
    }

    function canSwap(a, b) {
      if (!areNeighbors(a, b)) return false;
      const ta = grid[a];
      const tb = grid[b];
      if (!ta || !tb) return false;
      if (ta.frozen || tb.frozen) return false;
      return true;
    }

    function onCellTap(i) {
      if (animating || hearts <= 0 || gameOver) return;
      setTimeLeft(TIMER_SECONDS);
      if (!firstMoveRef.current) {
        startTimer();
        firstMoveRef.current = true;
      }

      if (selected === null) {
        if (grid[i].frozen) return;
        setSelected(i);
        return;
      }
      if (selected === i) {
        setSelected(null);
        return;
      }
      if (canSwap(selected, i)) {
        doSwap(selected, i);
        setSelected(null);
      } else {
        setHearts((h) => Math.max(0, h - 1));
        setSelected(null);
      }
    }

    function doSwap(a, b) {
      if (animating) return;
      const copy = grid.slice().map((t) => ({ ...t }));
      [copy[a], copy[b]] = [copy[b], copy[a]];
      setGrid(copy);
      setAnimating(true);
      setTimeout(() => {
        resolveCascades(copy).then((didMatch) => {
          if (!didMatch) {
            const revert = grid.slice().map((t) => ({ ...t }));
            setGrid(revert);
            setHearts((h) => Math.max(0, h - 1));
          }
          setAnimating(false);
        });
      }, 180);
    }

    async function resolveCascades(startGrid) {
      let anyMatch = false;
      const gridCopy = startGrid.slice().map((t) => ({ ...t }));
      while (true) {
        const matches = findMatches(gridCopy);
        if (!matches.size) break;
        anyMatch = true;
        const matchIndices = Array.from(matches);
        const shatterSet = new Set();
        matchIndices.forEach((idx) => {
          if (gridCopy[idx].frozen) shatterSet.add(idx);
        });
        const newMatched = new Map();
        matchIndices.forEach((i) =>
          newMatched.set(i, { type: gridCopy[i].frozen ? "shatter" : "pop", ts: Date.now() })
        );
        setMatchedMap(newMatched);
        setScore((s) => s + matchIndices.length * 10);
        if (shatterSet.size) {
          setHearts((h) => Math.min(START_HEARTS, h + shatterSet.size));
        }
        await new Promise((res) => setTimeout(res, 480));
        matchIndices.forEach((i) => {
          gridCopy[i] = emptyTile();
        });
        for (let c = 0; c < cols; c++) {
          let write = rows - 1;
          for (let r = rows - 1; r >= 0; r--) {
            const idx = rcToIndex(r, c);
            if (gridCopy[idx].kind !== null) {
              if (write !== r) {
                gridCopy[rcToIndex(write, c)] = gridCopy[idx];
                gridCopy[idx] = emptyTile();
              }
              write--;
            }
          }
          for (let r = write; r >= 0; r--) {
            gridCopy[rcToIndex(r, c)] = { kind: randKind(), frozen: spawnFrozenChance(score) > Math.random() };
          }
        }
        setGrid(gridCopy.map((t) => ({ ...t })));
        await new Promise((res) => setTimeout(res, 160));
      }
      setMatchedMap(new Map());
      setTimeLeft(TIMER_SECONDS);
      return anyMatch;
    }

    function findMatches(bd) {
      const matches = new Set();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols - 2; c++) {
          const idx = rcToIndex(r, c);
          const k = bd[idx].kind;
          if (k == null) continue;
          if (bd[idx + 1].kind === k && bd[idx + 2].kind === k) {
            let cc = c;
            while (cc < cols && bd[rcToIndex(r, cc)].kind === k) {
              matches.add(rcToIndex(r, cc));
              cc++;
            }
          }
        }
      }
      for (let c = 0; c < cols; c++) {
        for (let r = 0; r < rows - 2; r++) {
          const idx = rcToIndex(r, c);
          const k = bd[idx].kind;
          if (k == null) continue;
          if (bd[idx + cols].kind === k && bd[idx + 2 * cols].kind === k) {
            let rr = r;
            while (rr < rows && bd[rcToIndex(rr, c)].kind === k) {
              matches.add(rcToIndex(rr, c));
              rr++;
            }
          }
        }
      }
      return matches;
    }

    function spawnFrozenChance(currentScore) {
      const base = 0.05;
      const cap = 0.25;
      const extra = Math.min(cap - base, (currentScore / 2000) * (cap - base));
      return base + extra;
    }

    const boardStyle = {
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gridTemplateRows: `repeat(${rows}, 1fr)`
    };

    return React.createElement("div", { className: "game-container", role: "main", "aria-label": "Candy Land Match 3 game" },
      React.createElement("div", { className: "hud" },
        React.createElement("div", { className: "hearts", "aria-label": `${hearts} hearts left` }, "‚ù§ ".repeat(hearts)),
        React.createElement("div", { className: "score" }, `Score: ${score}`),
      ),
      React.createElement(TimerBar, { timeLeft, total: TIMER_SECONDS }),
      React.createElement("div", { className: "board", style: boardStyle, role: "grid" },
        grid.map((cell, i) => {
          const isSelected = selected === i;
          const matchedType = matchedMap.get(i)?.type;
          let animationClass = "";
          if (matchedType === "pop") animationClass = "matched-pop";
          else if (matchedType === "shatter") animationClass = "matched-shatter";

          return React.createElement("div", {
            key: i,
            className: `cell${isSelected ? " selected" : ""} ${animationClass}`,
            role: "gridcell",
            "aria-selected": isSelected,
            tabIndex: 0,
            onClick: () => onCellTap(i),
            onKeyDown: (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                onCellTap(i);
              }
            }
          },
            CANDIES[cell.kind] || "",
            cell.frozen && React.createElement("div", { className: "frozen-overlay", "aria-label": "Frozen candy" },
              React.createElement("svg", {
                className: "frozen-svg",
                xmlns: "http://www.w3.org/2000/svg",
                width: "36",
                height: "36",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "#66bbff",
                strokeWidth: "3",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              },
                React.createElement("polygon", { points: "12 2 15 8 22 9 17 14 18 21 12 18 6 21 7 14 2 9 9 8 12 2" })
              ),
              React.createElement("div", { className: "frozen-ice" })
            )
          );
        })
      ),
      gameOver && React.createElement("div", { role: "alert", "aria-live": "assertive" },
        React.createElement("div", { className: "game-over" }, "Game Over!"),
        React.createElement("div", { className: "game-over-info" },
          `Final Score: ${score}`, React.createElement("br"),
          `High Score: ${highScore}`
        ),
        React.createElement("button", {
          className: "restart-button",
          onClick: () => initBoard(rows, cols),
          autoFocus: true
        }, "Restart")
      )
    );
  }

  ReactDOM.createRoot(document.getElementById("root")).render(
    React.createElement(CandyLandMatch3)
  );
})();
</script>
</body>
</html>
