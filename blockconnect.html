<canvas id="game" tabindex="0" style="outline:none; width:100%; height:100%; display:block; background:#111;"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let w, h;
  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  const COLS = 10;
  const ROWS = 20;
  const BLOCK = Math.min(w / 20, h / 25);
  const OFFX = (w - COLS * BLOCK) / 2;
  const OFFY = (h - ROWS * BLOCK) / 2;

  const COLORS = [
    null,
    '#0ff', '#00f', '#f60', '#ff0',
    '#0c0', '#90c', '#f00'
  ];

  // Shapes as 4x4 arrays for all rotations (I,J,L,O,S,T,Z)
  const SHAPES = {
    I: [
      [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],
      [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],
      [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]
    ],
    J: [
      [[2,0,0],[2,2,2],[0,0,0]],
      [[0,2,2],[0,2,0],[0,2,0]],
      [[0,0,0],[2,2,2],[0,0,2]],
      [[0,2,0],[0,2,0],[2,2,0]]
    ],
    L: [
      [[0,0,3],[3,3,3],[0,0,0]],
      [[0,3,0],[0,3,0],[0,3,3]],
      [[0,0,0],[3,3,3],[3,0,0]],
      [[3,3,0],[0,3,0],[0,3,0]]
    ],
    O: [
      [[4,4],[4,4]],
      [[4,4],[4,4]],
      [[4,4],[4,4]],
      [[4,4],[4,4]]
    ],
    S: [
      [[0,5,5],[5,5,0],[0,0,0]],
      [[0,5,0],[0,5,5],[0,0,5]],
      [[0,0,0],[0,5,5],[5,5,0]],
      [[5,0,0],[5,5,0],[0,5,0]]
    ],
    T: [
      [[0,6,0],[6,6,6],[0,0,0]],
      [[0,6,0],[0,6,6],[0,6,0]],
      [[0,0,0],[6,6,6],[0,6,0]],
      [[0,6,0],[6,6,0],[0,6,0]]
    ],
    Z: [
      [[7,7,0],[0,7,7],[0,0,0]],
      [[0,0,7],[0,7,7],[0,7,0]],
      [[0,0,0],[7,7,0],[0,7,7]],
      [[0,6,0],[6,6,0],[6,0,0]]
    ]
  };

  const TYPES = Object.keys(SHAPES);
  const TYPE_TO_COLOR = {I:1,J:2,L:3,O:4,S:5,T:6,Z:7};

  // SRS kicks for normal pieces & I separately
  const kicksNormal = {
    '0>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    '1>0': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
    '1>2': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
    '2>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    '2>3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
    '3>2': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    '3>0': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    '0>3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  };
  const kicksI = {
    '0>1': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    '1>0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    '1>2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
    '2>1': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    '2>3': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    '3>2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    '3>0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    '0>3': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
  };

  let arena = [];
  for(let i=0; i<ROWS; i++) arena.push(new Array(COLS).fill(0));

  let player = {
    pos: {x:0,y:0},
    type: null,
    rotation: 0,
    matrix: null,
    nextType: null,
    nextRotation: 0,
    nextMatrix: null,
  };

  function buildMatrix(type, rotation) {
    return SHAPES[type][rotation].map(r=>r.slice());
  }
  function collide(arena, matrix, pos) {
    for(let y=0; y<matrix.length; y++) {
      for(let x=0; x<matrix[y].length; x++) {
        if(matrix[y][x] !== 0) {
          let px = pos.x + x;
          let py = pos.y + y;
          if(px < 0 || px >= COLS || py >= ROWS) return true;
          if(py >= 0 && arena[py][px]) return true;
        }
      }
    }
    return false;
  }
  function rotatePlayer(dir) {
    const oldRotation = player.rotation;
    const newRotation = (oldRotation + dir + 4) % 4;
    const kicks = player.type === 'I' ? kicksI : kicksNormal;
    const fromTo = `${oldRotation}>${newRotation}`;
    for(const [dx,dy] of (kicks[fromTo] || [[0,0]])) {
      const pos = {x:player.pos.x+dx,y:player.pos.y+dy};
      const matrix = buildMatrix(player.type, newRotation);
      if(!collide(arena,matrix,pos)) {
        player.rotation = newRotation;
        player.pos = pos;
        player.matrix = matrix;
        return;
      }
    }
  }
  function merge() {
    player.matrix.forEach((row,y) => {
      row.forEach((v,x) => {
        if(v) arena[y+player.pos.y][x+player.pos.x] = v;
      });
    });
  }
  function arenaSweep() {
    let lines = 0;
    outer: for(let y=ROWS-1;y>=0;y--) {
      for(let x=0;x<COLS;x++) {
        if(arena[y][x] === 0) continue outer;
      }
      arena.splice(y,1);
      arena.unshift(new Array(COLS).fill(0));
      lines++;
      y++;
    }
    return lines;
  }
  function playerReset() {
    player.type = player.nextType || TYPES[(Math.random()*TYPES.length)|0];
    player.rotation = 0;
    player.matrix = buildMatrix(player.type, 0);
    player.nextType = TYPES[(Math.random()*TYPES.length)|0];
    player.nextRotation = 0;
    player.nextMatrix = buildMatrix(player.nextType, 0);
    player.pos.y = 0;
    player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0);
    if(collide(arena, player.matrix, player.pos)) {
      arena = [];
      for(let i=0; i<ROWS; i++) arena.push(new Array(COLS).fill(0));
    }
  }
  function drawBlock(x,y,color) {
    ctx.fillStyle = COLORS[color];
    ctx.fillRect(OFFX + x * BLOCK, OFFY + y * BLOCK, BLOCK-1, BLOCK-1);
  }
  function drawMatrix(matrix, pos) {
    matrix.forEach((row,y) => {
      row.forEach((v,x) => {
        if(v) drawBlock(x + pos.x, y + pos.y, v);
      });
    });
  }
  function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, w, h);
    drawMatrix(arena, {x:0,y:0});
    drawMatrix(player.matrix, player.pos);

    ctx.fillStyle = '#0ff';
    ctx.font = `${BLOCK}px monospace`;
    ctx.fillText(`Score: ${score}`, 10, 30);
    ctx.fillText(`Best: ${best}`, 10, 60);
  }

  let dropCounter = 0;
  let dropInterval = 800;
  let lastTime = 0;
  let score = 0;
  let best = localStorage.getItem('tetrisBest')|0;

  function update(time=0) {
    const delta = time - lastTime;
    lastTime = time;
    dropCounter += delta;
    if(dropCounter > dropInterval) {
      player.pos.y++;
      if(collide(arena, player.matrix, player.pos)) {
        player.pos.y--;
        merge();
        const lines = arenaSweep();
        if(lines) {
          score += lines * 100;
          if(score > best) {
            best = score;
            localStorage.setItem('tetrisBest', best);
          }
        }
        playerReset();
      }
      dropCounter = 0;
    }
    draw();
    requestAnimationFrame(update);
  }

  window.addEventListener('keydown', e => {
    if(e.key === 'ArrowLeft') {
      player.pos.x--;
      if(collide(arena, player.matrix, player.pos)) player.pos.x++;
    }
    else if(e.key === 'ArrowRight') {
      player.pos.x++;
      if(collide(arena, player.matrix, player.pos)) player.pos.x--;
    }
    else if(e.key === 'ArrowDown') {
      player.pos.y++;
      if(collide(arena, player.matrix, player.pos)) {
        player.pos.y--;
        merge();
        const lines = arenaSweep();
        if(lines) {
          score += lines * 100;
          if(score > best) {
            best = score;
            localStorage.setItem('tetrisBest', best);
          }
        }
        playerReset();
      }
      dropCounter = 0;
    }
    else if(e.key === 'ArrowUp') {
      rotatePlayer(1);
    }
    else if(e.key === ' ') {
      // Hard drop
      while(!collide(arena, player.matrix, {x:player.pos.x, y:player.pos.y + 1})) {
        player.pos.y++;
      }
      merge();
      const lines = arenaSweep();
      if(lines) {
        score += lines * 100;
        if(score > best) {
          best = score;
          localStorage.setItem('tetrisBest', best);
        }
      }
      playerReset();
      dropCounter = 0;
    }
  });

  playerReset();
  update();
})();
</script>
